正则：
    主要用来匹配（擅长匹配模糊范围的）字符串，是一种规则，效率更高
速度更快，但是，可维护性较差（因为读起来很费劲）
	 	
需求
    1. 找到字符串中的数字，存在数组中
				
    创建一个新的数组，循环每个字符，
    如果某个字符为数字那么就把这个数字push到数组中.
				
    string[i] 在IE6下不支持，所以用string.charAt(i)
				
			
    2. 找到字符串中的数字以及连续的数字，存在数组中
    str = '3d1sa1d21s1ax'  ->3,1,1,21,1
				
    建一个空的字符串，当某个字符为数字的时候，那么给这个空的字符串进行拼接，当某个不是数字的时候就把已经拼接好的字符串push到数组中并且清空拼接的字符，以便下次使用。
    写法一：
简写：/规则/    这种性能要更高。
		
写法二：
   new RegExp(字符串的规则,修饰符);
			
转义符：
			
    \+字符，如果这个组合在系统中已经有默认定制，那么就为特殊的转义符
			
    转义符后面跟上一个普通的字符，代表一个或一段特殊的内容

			
    \n  换行
    \r  回车
    \t  制表符
    .....
正则的方法：
1.test
查看正则表达式与指定的字符串是否匹配,如果是返回一个布尔值（true），否则false
				
*正则身上的方法。
[] 任取其一 
		
	
		
    修饰符：
    g  -> global  全局
			
    re.test(str)
正则的方法：
			
match：
    将匹配到的字符放到一个数组中。
				
字符串的方法:
    str.match(正则)
			
修饰符：
    g  -> global  全局
		
量词：
    +：最少有1个，最多不限
			
特殊的转义符：
    \d 一个数字
			
正则的特性：
    懒惰：
        匹配到某个规则之后，那么直接返回。
				
    贪婪:
会一直找量词中匹配的字符，有多少就匹配多少。
    search:（找到字符串中指定字符(正则)的位置,找到返回位置，没找到返回-1）
   字符串的方法：
    str.search(''||re);
				
    修饰符：
    i:忽略大小写。
修饰符：不分前后顺序
		
replace()：
字符串的方法
		
将字符串指定的字符（正则）替换成另外的字符。
		
str.replace(要替换哪个||正则,替换成什么||回调函数);
		
回调中必须写return，不然会为undefined
如果只传一个参数，那么匹配到的字符就会被替换为undefined
\D 非数字  
		
		
? 最小可以没有，最大有一个
		
子项 ()
从左往右依次计算
		
只要在正则有子项，那么replace回调函数中的第二个参数开始，就是匹配到的子项（不再是索引）
括号除了子项，还有提权
[] 任取其一 
		
^ 开头  
		
如果 [] + ^ 那么写就为 排除
量词：
+
?
{n,m}  最小多少个，最大多少个
			
	{n,}   最小多少，最多不限
			
	{1,}  最小1次，最多不限    +
			
	{0,1}   最小0次，最多1次  ?
			
	{0,}   最小可以没有，最大无限
			
			
注意：
	量词都是修饰前面那个规则的
	比如：
	a*    a可以没有也可以无限
	[a-z]*  a-z 可以没有也可以无限
	\d2+  一个数字和至少1个2   
	(\d2)+  32526272
			
	n:最小
	m:最大
	{3,}
qq:
	全是数字、最小5位最大11，不能以0开头
li active
active li
		
空格 + li
		
/^|\s/ + li
		
/^$/
		
new RegExp(***必须为字符串) 
		
/a/
new RegExp('/a/') ->  /\/a\//   \\s   \s
字符串中也不能随便写\，如果非要写，就转义\
new RegExp(必须为字符串)
		
***如果在字符串中有\必须转义。
边界符：
\b
在数字、字母、下划线中是有边界符的。
\d 一个数字 
		\D 非数字
		\s 一个空格
		\S 非空格
		\w 数字 字母 下划线
		\W 非数字，字母，下划线
		\b 单词的边界符	
	    \B 非边界符
		.任意一个字符(除了\n)